{"version":3,"file":"static/webpack/static/development/pages/number-format.js.24659dea40d526728500.hot-update.js","sources":["webpack:///./pages/number-format/index.js"],"sourcesContent":["/* @flow */\n\nimport * as React from 'react';\nimport * as ReactDOM from 'react-dom';\nimport { Rifm } from 'rifm';\n\n// To prevent parseInt overflow you can use `maxLength` on input field\n// or write your own numberFormat.\n\nconst integerAccept = /\\d+/g;\n\nconst parseInteger = string => (string.match(integerAccept) || []).join('');\n\nconst formatInteger = string => {\n  const parsed = parseInteger(string);\n  const number = Number.parseInt(parsed, 10);\n  if (Number.isNaN(number)) {\n    return '';\n  }\n  return number.toLocaleString('en');\n};\n\nconst negativeAccept = /[\\d-]+/g;\n\nconst parseNegative = string => (string.match(negativeAccept) || []).join('');\n\nconst formatNegative = string => {\n  const parsed = parseNegative(string);\n  if (parsed === '-') {\n    return '-';\n  }\n  const number = Number.parseInt(parsed, 10);\n  if (Number.isNaN(number)) {\n    return '';\n  }\n  return number.toLocaleString('en');\n};\n\nconst truncScale = (number, scale) => {\n  const ratio = 10 ** scale;\n  return Math.trunc(number * ratio) / ratio;\n};\n\nconst numberAccept = /[\\d.]+/g;\n\nconst parseNumber = string => (string.match(numberAccept) || []).join('');\n\nconst formatFixedPointNumber = (value, digits) => {\n  const parsed = parseNumber(value);\n  const [head, tail] = parsed.split('.');\n  let number;\n\n  // For fixed format numbers deleting \".\" must be no-op\n  // as imagine u have 123.45 then delete \".\" and get 12345.00 looks bad in UI\n  // so we transform here 12345 into 123.45 instead of 12345.00.\n  // The main disadvantage of this, that you need carefully check input value\n  // that it always has fractional part\n  if (digits > 0 && tail == null) {\n    const paddedHead = head.padStart(digits + 1 - head.length, '0');\n    number = Number.parseFloat(\n      `${paddedHead.slice(0, -digits)}.${paddedHead.slice(-digits)}`\n    );\n  } else {\n    number = Number.parseFloat(parsed);\n  }\n\n  if (Number.isNaN(number)) {\n    return '';\n  }\n\n  // Avoid rounding errors at toLocaleString as when user enters 1.239 and maxDigits=2 we\n  // must not to convert it to 1.24, it must stay 1.23\n  number = truncScale(number, digits);\n\n  const formatted = number.toLocaleString('de-CH', {\n    minimumFractionDigits: digits,\n    maximumFractionDigits: digits,\n  });\n\n  return formatted;\n};\n\nconst formatFloatingPointNumber = (value, maxDigits) => {\n  const parsed = parseNumber(value);\n  const [head, tail] = parsed.split('.');\n  // Avoid rounding errors at toLocaleString as when user enters 1.239 and maxDigits=2 we\n  // must not to convert it to 1.24, it must stay 1.23\n  const scaledTail = tail != null ? tail.slice(0, maxDigits) : '';\n\n  const number = Number.parseFloat(`${head}.${scaledTail}`);\n\n  if (Number.isNaN(number)) {\n    return '';\n  }\n\n  const formatted = number.toLocaleString('de-CH', {\n    minimumFractionDigits: 0,\n    maximumFractionDigits: maxDigits,\n  });\n\n  if (parsed.includes('.')) {\n    const [formattedHead] = formatted.split('.');\n\n    // skip zero at digits position for non fixed floats\n    // as at digits 2 for non fixed floats numbers like 1.50 has no sense, just 1.5 allowed\n    // but 1.0 has sense as otherwise you will not be able to enter 1.05 for example\n    const formattedTail =\n      scaledTail !== '' && scaledTail[maxDigits - 1] === '0'\n        ? scaledTail.slice(0, -1)\n        : scaledTail;\n\n    return `${formattedHead}.${formattedTail}`;\n  }\n  return formatted;\n};\n\n// 2 in m^2 should not be a number to not match regexp\nconst formatMeters = string =>\n  formatFloatingPointNumber(string, 2) + ' m\\u00B2';\n\nconst formatCurrency = string => '$' + formatFloatingPointNumber(string, 2);\n\nconst Example = () /*:React.Node*/ => {\n  const [integer, setInteger] = React.useState('12345');\n  const [negative, setNegative] = React.useState('12345');\n  const [variableFloat, setVariableFloat] = React.useState('12345');\n  const [fixedFloat, setFixedFloat] = React.useState('12345');\n\n  return (\n    <Grid>\n      <div>\n        <div>Integer number format: {integer}</div>\n        <Rifm\n          accept={/\\d/g}\n          format={formatInteger}\n          value={integer}\n          onChange={value => setInteger(parseInteger(value))}\n        >\n          {renderInput}\n        </Rifm>\n      </div>\n\n      <div>\n        <div>Negative number format: {negative}</div>\n        <Rifm\n          accept={/[\\d-]/g}\n          format={formatNegative}\n          value={negative}\n          onChange={value => setNegative(parseNegative(value))}\n        >\n          {renderInput}\n        </Rifm>\n      </div>\n\n      <div>\n        <div>Number with fractional part: {fixedFloat}</div>\n        <Rifm\n          accept={/[\\d.]/g}\n          format={v => formatFixedPointNumber(v, 2)}\n          // 00 is needed here see disadvantages comment at formatNumber\n          value={`${fixedFloat}00`}\n          onChange={value => setFixedFloat(parseNumber(value))}\n        >\n          {renderInput}\n        </Rifm>\n      </div>\n\n      <div>\n        <div>Number with variable fractional part: {variableFloat}</div>\n        <Rifm\n          accept={/[\\d.]/g}\n          format={v => formatFloatingPointNumber(v, 2)}\n          value={variableFloat}\n          onChange={value => setVariableFloat(parseNumber(value))}\n        >\n          {renderInput}\n        </Rifm>\n      </div>\n\n      <div>\n        <div>Square meters number: {variableFloat}</div>\n        <Rifm\n          accept={/[\\d.]/g}\n          format={formatMeters}\n          value={variableFloat}\n          onChange={value => setVariableFloat(parseNumber(value))}\n        >\n          {renderInput}\n        </Rifm>\n      </div>\n\n      <div>\n        <div>Currency number: {variableFloat}</div>\n        <Rifm\n          // $ need to be in regexp to prevent cursor jumping on backspace\n          accept={/[\\d.$]/g}\n          format={formatCurrency}\n          value={variableFloat}\n          onChange={value => setVariableFloat(parseNumber(value))}\n        >\n          {renderInput}\n        </Rifm>\n      </div>\n    </Grid>\n  );\n};\n\nconst renderInput = ({ value, onChange }) => (\n  // type=number is not allowed\n  <input\n    type=\"tel\"\n    style={{\n      textAlign: 'right',\n      width: '100%',\n      height: 32,\n      fontSize: 'inherit',\n      boxSizing: 'border-box',\n    }}\n    value={value}\n    onChange={onChange}\n  />\n);\n\nconst Grid = ({ children }) => {\n  return (\n    <div\n      style={{\n        display: 'grid',\n        padding: 16,\n        gap: 24,\n        gridTemplateColumns: 'repeat(auto-fit, minmax(240px, 1fr))',\n        alignItems: 'end',\n      }}\n    >\n      {children}\n    </div>\n  );\n};\n\nif (typeof document !== 'undefined') {\n  const root = document.getElementById('root');\n  if (root) {\n    ReactDOM.render(<Example />, root);\n  }\n}\n\nexport default Example;\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAEA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAFA;AAAA;AAAA;AAAA;AACA;AAEA;AAGA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AADA;AAEA;AACA;AACA;AAFA;AAKA;AACA;AACA;AACA;AACA;AACA;AAFA;AAAA;AAAA;AAAA;AAIA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAFA;AACA;AAIA;AAAA;AAAA;AAAA;AAIA;AACA;AACA;AACA;AADA;AAKA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAEA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AADA;AAAA;AAAA;AAAA;AACA;AADA;AAAA;AAAA;AAAA;AACA;AADA;AAAA;AAAA;AAAA;AACA;AAKA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AAAA;AAAA;AAJA;AAAA;AAAA;AAAA;AAAA;AAAA;AAUA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AAAA;AAAA;AAJA;AAAA;AAAA;AAAA;AAAA;AAAA;AAUA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AAAA;AAAA;AAFA;AAIA;AACA;AAAA;AAAA;AALA;AAAA;AAAA;AAAA;AAAA;AAAA;AAWA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAJA;AAAA;AAAA;AAAA;AAAA;AAAA;AAUA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AAAA;AAAA;AAJA;AAAA;AAAA;AAAA;AAAA;AAAA;AAUA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AACA;AAAA;AAAA;AALA;AAAA;AAAA;AAAA;AAAA;AAAA;AAYA;AACA;AACA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AALA;AAOA;AACA;AAVA;AAAA;AAAA;AAAA;AAAA;AAAA;AAFA;AAAA;AACA;AAeA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AALA;AADA;AAAA;AAAA;AAAA;AAAA;AAAA;AAYA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;;;;A","sourceRoot":""}