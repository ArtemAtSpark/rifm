{"version":3,"file":"static/webpack/static/development/pages/date-format.js.41077dc8c0ab5be1b979.hot-update.js","sources":["webpack:///./src/Rifm.js"],"sourcesContent":["/* @flow */\n\nimport * as React from 'react';\n\ntype Props = {|\n  value: string,\n  onChange: string => void,\n  format: (str: string) => string,\n  mask?: boolean,\n  replace?: string => string,\n  append?: string => string,\n  accept?: RegExp,\n  children: ({\n    value: string,\n    onChange: (\n      evt: SyntheticInputEvent<HTMLInputElement | HTMLTextAreaElement>\n    ) => void,\n  }) => React.Node,\n|};\n\nexport const Rifm = (props: Props) => {\n  const [, refresh] = React.useReducer(c => c + 1, 0);\n  const valueRef = React.useRef(null);\n  const { replace = v => v, append = v => v } = props;\n  const userValue = replace\n    ? replace(props.format(props.value))\n    : props.format(props.value);\n\n  // state of delete button see comments below about inputType support\n  const isDeleleteButtonDownRef = React.useRef(false);\n\n  const onChange = (\n    evt: SyntheticInputEvent<HTMLInputElement | HTMLTextAreaElement>\n  ) => {\n    if (process.env.NODE_ENV !== 'production') {\n      if (evt.target.type === 'number') {\n        console.error(\n          'Rifm does not support input type=number, use type=tel instead.'\n        );\n        return;\n      }\n    }\n\n    const eventValue = evt.target.value;\n\n    valueRef.current = [\n      eventValue, // eventValue\n      evt.target, // input\n      eventValue.length > userValue.length, // isSizeIncreaseOperation\n      isDeleleteButtonDownRef.current, // isDeleleteButtonDown\n      userValue === props.format(eventValue), // isNoOperation\n    ];\n\n    if (process.env.NODE_ENV !== 'production') {\n      const formattedEventValue = props.format(eventValue);\n      if (\n        eventValue !== formattedEventValue &&\n        eventValue.toLowerCase() === formattedEventValue.toLowerCase()\n      ) {\n        console.warn(\n          'Case enforcement does not work with format. Please use replace={value => value.toLowerCase()} instead'\n        );\n      }\n    }\n\n    // The main trick is to update underlying input with non formatted value (= eventValue)\n    // that allows us to calculate right cursor position after formatting (see getCursorPosition)\n    // then we format new value and call props.onChange with masked/formatted value\n    // and finally we are able to set cursor position into right place\n    refresh();\n  };\n\n  // React prints warn on server in non production mode about useLayoutEffect usage\n  // in both cases it's noop\n  if (process.env.NODE_ENV === 'production' || typeof window !== 'undefined') {\n    React.useLayoutEffect(() => {\n      if (valueRef.current == null) return;\n\n      let [\n        eventValue,\n        input,\n        isSizeIncreaseOperation,\n        isDeleleteButtonDown,\n        // No operation means that value itself hasn't been changed, BTW cursor, selection etc can be changed\n        isNoOperation,\n      ] = valueRef.current;\n      valueRef.current = null;\n\n      // this usually occurs on deleting special symbols like ' here 123'123.00\n      // in case of isDeleleteButtonDown cursor should move differently vs backspace\n      const deleteWasNoOp = isDeleleteButtonDown && isNoOperation;\n\n      // Create string from only accepted symbols\n      const clean = str => (str.match(props.accept || /\\d/g) || []).join('');\n\n      const valueBeforeSelectionStart = clean(\n        eventValue.substr(0, input.selectionStart)\n      );\n\n      // trying to find cursor position in formatted value having knowledge about valueBeforeSelectionStart\n      // This works because we assume that format doesn't change the order of accepted symbols.\n      // Imagine we have formatter which adds ' symbol between numbers, and by default we refuse all non numeric symbols\n      // for example we had input = 1'2|'4 (| means cursor position) then user entered '3' symbol\n      // inputValue = 1'23'|4 so valueBeforeSelectionStart = 123 and formatted value = 1'2'3'4\n      // calling getCursorPosition(\"1'2'3'4\") will give us position after 3, 1'2'3|'4\n      // so for formatting just this function to determine cursor position after formatting is enough\n      // with masking we need to do some additional checks see `mask` below\n      const getCursorPosition = val => {\n        let start = 0;\n        let cleanPos = 0;\n\n        for (let i = 0; i !== valueBeforeSelectionStart.length; ++i) {\n          let newPos = val.indexOf(valueBeforeSelectionStart[i], start) + 1;\n\n          let newCleanPos =\n            clean(val).indexOf(valueBeforeSelectionStart[i], cleanPos) + 1;\n\n          // this skips position change if accepted symbols order was broken\n          // For example fixes edge case with fixed point numbers:\n          // You have '0|.00', then press 1, it becomes 01|.00 and after format 1.00, this breaks our assumption\n          // that order of accepted symbols is not changed after format,\n          // so here we don't update start position if other accepted symbols was inbetween current and new position\n          if (newCleanPos - cleanPos > 1) {\n            newPos = start;\n            newCleanPos = cleanPos;\n          }\n\n          cleanPos = Math.max(newCleanPos, cleanPos);\n          start = Math.max(start, newPos);\n        }\n        return start;\n      };\n\n      // Masking part, for masks if size of mask is above some value\n      // we need to replace symbols instead of do nothing as like in format\n      if (props.mask === true && isSizeIncreaseOperation && !isNoOperation) {\n        let start = getCursorPosition(eventValue);\n\n        const c = clean(eventValue.substr(start))[0];\n        start = eventValue.indexOf(c, start);\n\n        eventValue = `${eventValue.substr(0, start)}${eventValue.substr(\n          start + 1\n        )}`;\n      }\n\n      let formattedValue = props.format(eventValue);\n\n      if (\n        append != null &&\n        // cursor at the end\n        input.selectionStart === eventValue.length &&\n        !isNoOperation\n      ) {\n        if (isSizeIncreaseOperation) {\n          formattedValue = append(formattedValue);\n        } else {\n          // If after delete last char is special character and we use append\n          // delete it too\n          // was: \"12-3|\" backspace pressed, then should be \"12|\"\n          if (clean(formattedValue.slice(-1)) === '') {\n            formattedValue = formattedValue.slice(0, -1);\n          }\n        }\n      }\n\n      const replacedValue = replace ? replace(formattedValue) : formattedValue;\n\n      if (userValue === replacedValue) {\n        // if nothing changed for formatted value, just refresh so userValue will be used at render\n        refresh();\n      } else {\n        props.onChange(replacedValue);\n      }\n\n      return () => {\n        let start = getCursorPosition(formattedValue);\n\n        // Visually improves working with masked values,\n        // like cursor jumping over refused symbols\n        // as an example date mask: was \"5|1-24-3\" then user pressed \"6\"\n        // it becomes \"56-|12-43\" with this code, and \"56|-12-43\" without\n        if (\n          props.mask != null &&\n          (isSizeIncreaseOperation || (isDeleleteButtonDown && !deleteWasNoOp))\n        ) {\n          while (formattedValue[start] && clean(formattedValue[start]) === '') {\n            start += 1;\n          }\n        }\n\n        input.selectionStart = input.selectionEnd =\n          start + (deleteWasNoOp ? 1 : 0);\n      };\n    });\n  }\n\n  React.useEffect(() => {\n    // until https://developer.mozilla.org/en-US/docs/Web/API/InputEvent/inputType will be supported\n    // by all major browsers (now supported by: +chrome, +safari, ?edge, !firefox)\n    // there is no way I found to distinguish in onChange\n    // backspace or delete was called in some situations\n    // firefox track https://bugzilla.mozilla.org/show_bug.cgi?id=1447239\n    const handleKeyDown = (evt: KeyboardEvent) => {\n      if (evt.code === 'Delete') {\n        isDeleleteButtonDownRef.current = true;\n      }\n    };\n\n    const handleKeyUp = (evt: KeyboardEvent) => {\n      if (evt.code === 'Delete') {\n        isDeleleteButtonDownRef.current = false;\n      }\n    };\n\n    document.addEventListener('keydown', handleKeyDown);\n    document.addEventListener('keyup', handleKeyUp);\n\n    return () => {\n      document.removeEventListener('keydown', handleKeyDown);\n      document.removeEventListener('keyup', handleKeyUp);\n    };\n  }, []);\n\n  return props.children({\n    value: valueRef.current != null ? valueRef.current[0] : userValue,\n    onChange,\n  });\n};\n"],"mappings":";;;;;;;;;;;;;;;;AAEA;AAkBA;AAAA;AACA;AAAA;AADA;AAAA;AACA;AACA;AAFA;AAAA;AAGA;AAAA;AAHA;AAAA;AAGA;AAAA;AACA;AACA;AAIA;AACA;AACA;AAGA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AAIA;AAGA;AACA;AAGA;AACA;AACA;AACA;AACA;AADA;AACA;AAGA;AACA;AACA;AADA;AACA;AACA;AACA;AAFA;AAAA;AAAA;AAAA;AAAA;AAAA;AASA;AACA;AACA;AAGA;AACA;AAAA;AACA;AAEA;AAAA;AAAA;AACA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AAIA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAGA;AACA;AACA;AADA;AACA;AAEA;AACA;AAEA;AAGA;AACA;AACA;AACA;AACA;AAGA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AAAA;AAIA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAFA;AAIA;;;;A","sourceRoot":""}